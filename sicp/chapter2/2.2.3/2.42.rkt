#lang sicp
(#%require "../util.rkt")
(#%require "./base.rkt")
(#%require "./prime-sum-pair.rkt")

(define (last seq)
  (define (inner seq prev)
    (if(null? seq)
       prev
       (inner (cdr seq) (car seq))
       )
    )
  (inner seq nil)
  )
(define (queens board-size)
  ; (define empty-board (map (lambda (new-row)(list)) (enumerate-interval 1 board-size)))
  (define empty-board '())
  ; (display empty-board)
  (define (safe? k positions)
    (define (iter-check row-of-new-queen rest-of-queens i)
      (cond
        ((null? rest-of-queens) true)
        ((= row-of-new-queen (car rest-of-queens)) false)
        ((= (- row-of-new-queen (car rest-of-queens)) i) false)
        ((= (- (car rest-of-queens) row-of-new-queen ) i) false)
        (else
         ( iter-check row-of-new-queen (cdr rest-of-queens) (+ i 1))
         )
        )
      )
    (iter-check (car positions) (cdr positions) 1)
    )
  (define (adjoin-position new-row k rest-of-queens)
    (cons new-row rest-of-queens)
    )
  (define (queen-cols k)
    (if (= k 0)
        (list empty-board)
        (filter (lambda(positions) (safe? k positions))
                (flatmap (lambda(rest-of-queens)
                           (map (lambda (new-row)
                                  (adjoin-position new-row k rest-of-queens)
                                  )
                                (enumerate-interval 1 board-size)))

                         (queen-cols (- k 1))
                         )
                )
        )
    )
  (queen-cols board-size)
  )
(queens 8)

; (define l1 (list (cons 1 2) (cons 3 4) (cons 5 6)))
; (define l1 (list ))
; l1
; (reverse l1)
; (last l1)