+ 面向对象的语言有一个标识，那就是他们都有类的概念，而通过类可以创建任意多个具有相同属性和方法的对象。
6.1 理解对象
   对象字面量创建对象
   6.1.1 属性类型
    Object.definePorperty()
      ECMA-262第5版定义只有内部才用的特性(attribute)时，描述了属性(property)的各种特征。
      ECMAScript中有两种属性： 数据属性和访问器属性
      1.数据属性（为了表示室内布置，该规范把它们放在了两对方括号中）
         [[Configurable]] // true 表示能否通过delete删除尚需经从而红新定义属性，能否修改属性的特性或者能否把属性修改为访问器属性
         [[Enumerable]]  //true  表示能否通过for-in 循环返回属性。
         [[Writable]]  //true 表示能否修改属性的值
         [[Value]] // undefined 包含这个属性的数据值。读取属性值的时候，从这个为只读，写入属性值的时候，把心智保存在这个位置。
      2.访问器属性
         [[get]]
         [[set]]
         // 访问器属性的常见方式，及设置一个属性的值会导致其它属性发生变化。
   6.1.2 定义多个属性
    Object.definePorperties()
   6.1.3 读取属性的特性
    Object.getOwnPropertyDescriptor()方法
6.2 创建对象
   6.2.1 工厂模式 （工厂模式虽然解决了创建多个相似对象的问题，但却没有解决对象识别的问题，机怎样知道一个对象的类型）
   6.2.2 构造函数模式
      函数名大写

      创建的时候必须使用new 操作符。以这种方式调用构造函数实际上会经历一下4个不走
         1.创建一个对象
         2.将构造函数的作用域赋给新对象
         3.执行构造函数中的代码
         4.返回新对象
     1.将构造函数当做函数
         构造函数和其他函数的唯一区别，就在于调用它们的方式不同。任何函数，只要通过new操作符来调用，那他就可以作为构造函数。
     2.构造函数问题
         使用构造函数的主要问题就是每个方法都要在每个实例上重新创建一遍。 不要忘了--ECMA中的函数是对象，因此美定义一个函数，也就是
         实例化了一个对象。
         以这种方式创建函数，会导致不同的作用域和标识符解析，但创建Function新实例的机制任然是相同的。一次，不同实例上的同名函数是不相等的

         创建两个完成同样任务的Function实例没有必要，康且有this对象再，
6.2.3 原型模式
   我们创建的每一个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以有特定类型的所有实
   ・例共享的属性和方法。

